# -*- coding: utf-8 -*-
"""Untitled76.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WbmltlLAdsOsUu0br7fgKupB3fBtbqPw
"""

# install faker and import the faker library
from faker import Faker
from collections import namedtuple
from time import perf_counter
from functools import wraps
import datetime
from statistics import mode
from numpy import random
from datetime import date

# Create a  Faker object
faker = Faker()
# Generate a faker profile
faker.profile()


# A Decorator Wrapper calculating the execution time
def calc_time(fn):
    """
    Decorator to determine execution time of decorated fn.
    """

    @wraps(fn)
    def inner(*args, **kwargs) -> "Function Output":
        """
        Inner function to calculate the time.
        """
        start = perf_counter()
        result = fn(*args, **kwargs)
        exec_time = (perf_counter() - start)
        return exec_time, result

    return inner


"""
Q1.Use the Faker (Links to an external site.)library to get 10000 random profiles. 
Using namedtuple, calculate the largest blood type, mean-current_location, oldest_person_age,
and average age (add proper doc-strings).
"""


def init_profiles_using_namedtuple(number: int):
    """
    Creating faker profiles for given number of people using namedtuples
    """
    profiles = []
    Profile = namedtuple('Profile', faker.profile().keys())
    for _ in range(number):
        profiles.append(Profile(*faker.profile().values()))
    return profiles


@calc_time
def oldest_person_in_namedtuple(all_profile_in_namedtuple: namedtuple) -> float:
    """
    This function finds the oldest person from the slot, calculates the duration. The minimum birthdate and
    time is returned.
    # Param:
        all_profile_nt: Named tuple containing all  profiles
    """
    value = min(all_profile_in_namedtuple, key=lambda v: v[-1])
    date_today = datetime.date.today()
    age = (date_today - value.birthdate).days
    return int(age / 365)


@calc_time
def average_age_in_namedtuple(all_profile_in_namedtuple: namedtuple) -> tuple:
    """
    This function finds the average age of the person from the slot, calculates the duration to perform that operation.
    The average age and time is returned.
    # Param:
        all_profile_nt: Named tuple containing all  profiles
    """
    today = date.today()
    value = sum(map(lambda v: today.year - v[-1].year - ((today.month, today.day) < (v[-1].month, v[-1].day)),
                    all_profile_in_namedtuple)) / len(all_profile_in_namedtuple)
    return value


@calc_time
def max_bloodgroup_in_namedtuple(all_profile_in_namedtuple: namedtuple) -> tuple:
    """
    This function uses the mode function defined in statisics library to find the most occured blood group from the list
    The list is generated using the lambda function and returned to the mode function as a parameters.
    The code is then timed and the result and time is sent back.
    # Param:
        all_profile_nt: Named tuple containing all  profiles
    """
    blood_group = mode(list(map(lambda v: v[5], all_profile_in_namedtuple)))
    return blood_group


@calc_time
def average_coords_in_namedtuple(all_profile_in_namedtuple: namedtuple) -> tuple:
    """
    This function finds the average coordinates  from the slot, calculates the duration to perform that operation.
    The average coordinates and time is returned.
    # Param:
        all_profile_nt: Named tuple containing all  profiles
    """
    x, y = sum(map(lambda t: t[0], map(lambda v: v[4], all_profile_in_namedtuple))) / len(
        all_profile_in_namedtuple), sum(map(lambda t: t[1], map(lambda v: v[4], all_profile_in_namedtuple))) / len(
        all_profile_in_namedtuple)
    return x, y


def time_for_named_tuple(fk_profile_in_namedtuple: namedtuple, n: int) -> 'float':
    ti = 0
    for _ in range(n):
        total_exec_time_nt = oldest_person_in_namedtuple(fk_profile_in_namedtuple)[0] + \
                             average_age_in_namedtuple(fk_profile_in_namedtuple)[0] + \
                             average_coords_in_namedtuple(fk_profile_in_namedtuple)[0] + \
                             max_bloodgroup_in_namedtuple(fk_profile_in_namedtuple)[0]
        ti += total_exec_time_nt
    return ti / n


"""##Question 2
Do the same thing above using a dictionary. Prove that namedtuple is faster.
"""


# Converting the Data generated above as list of Dictionary

def namedtupletodict(all_profile_in_namedtuple: namedtuple) -> dict:
    return {'Profile' + str(i): t._asdict() for i, t in enumerate(all_profile_in_namedtuple)}


@calc_time
def oldest_person_dict(all_profile_dict: dict) -> float:
    """
    This function finds the oldest person from the slot, calculates the duration. The minimum birthdate and
    time is returned.
    # Param:
        all_profile_dc: dictionary containing all  profiles
    """
    value = min(all_profile_dict.values(), key=lambda v: v['birthdate'])
    date_today = datetime.date.today()
    age = (date_today - value['birthdate']).days
    return int(age / 365)


@calc_time
def average_coords_dict(all_profile_dict: dict) -> tuple:
    """
    This function finds the average coordinates  from the slot, calculates the duration to perform that operation.
    The average coordinates and time is returned.
    # Param:
        all_profile_dc: dictionary containing all profiles
    """
    x, y = sum(map(lambda t: t[0], map(lambda v: v['current_location'], all_profile_dict.values()))) / len(
        all_profile_dict.values()), sum(
        map(lambda t: t[1], map(lambda v: v['current_location'], all_profile_dict.values()))) / len(
        all_profile_dict.values())
    return x, y


@calc_time
def max_bloodgroup_dict(all_profile_dict: dict) -> tuple:
    """
    This function uses the mode function defined in statisics library to find the most occured blood group from the
    list. The list is generated using the lambda function and returned to the mode function as a parameters. The code is
    then timed and the result and time is sent back.
    # Param:
        all_profile_dc: dictionary containing all profiles
    """
    value = mode(list(map(lambda v: v['blood_group'], all_profile_dict.values())))
    return value


@calc_time
def average_age_dict(all_profile_dict: dict) -> float:
    """
    This function finds the average age of the person from the slot, calculates the duration to perform that operation.
    The average age and time is returned.
    # Param:
        all_profile_dc: Dictionary containing all  profiles
    """
    today = date.today()
    value = sum(map(lambda v: today.year - v['birthdate'].year - (
            (today.month, today.day) < (v['birthdate'].month, v['birthdate'].day)),
                    all_profile_dict.values())) / len(all_profile_dict)
    return value


def time_for_dict(fk_profile_dict: dict, n: int) -> 'float':
    ti = 0
    for _ in range(n):
        total_exec_time_dict = oldest_person_dict(fk_profile_dict)[0] + average_age_dict(fk_profile_dict)[0] + \
                             average_coords_dict(fk_profile_dict)[0] + max_bloodgroup_dict(fk_profile_dict)[0]
        ti += total_exec_time_dict
    return ti / n


"""##Question3
Create faker data (you can use Faker for company names) for imaginary stock exchange for top 100 companies 
(name, symbol, open, high, close). Assign a random weight to all the companies. Calculate and show what value the 
stock market started at, what was the highest value during the day, and where did it end. Make sure your open, high, 
close are not totally random. You can only use namedtuple.
"""


# Returns a Symbol for the Company
def symbol(string):
    """Returns joined string if characters are upper case"""
    length = len(string)
    p1 = random.randint(1, length - 1, 2)
    chars = []
    for char in string:
        chars.append(char)
    chars[p1[0]] = chars[p1[0]].upper()
    chars[p1[1]] = chars[p1[1]].upper()

    return ''.join(x for x in chars if x.isupper())


def stock_market(n=100):
    """
    To create a faker stock data set for imaginary stock exchange for top 100 companies (name, symbol, open, high, close
    ).Tasks_ToDo: Assign a random weight to all the companies. Calculate and show what value stock market started at
    .what was the highest value during the day and where did it end.
    """
    all_companies = []
    Stocks = namedtuple("Stocks", 'name symbol open high close company_weight')
    mkvalue = random.uniform(1000, 50000, 100)
    wts_ = random.uniform(0, 1, 100)
    wts_ = wts_ / sum(wts_)

    for _ in range(n):
        name = faker.company()
        open_ = round(mkvalue[_], 2) * wts_[_]
        close = round(open_ * random.uniform(0.7, 1.15), 2)
        high = round(open_ * random.uniform(0.90, 1.15), 2)
        if high < open_:
            high = open_
        if high < close:
            high = close

        all_companies.append(
            Stocks(name=name, symbol=symbol(name), open=open_, high=round(high, 2), close=round(close, 2),
                   company_weight=round(wts_[_], 4)))

    stock_index = round(sum(x.open * x.company_weight for x in all_companies), 4)
    highest_for_day = round(sum(x.high * x.company_weight for x in all_companies), 2)
    lowest_close_for_day = round(sum(x.close * x.company_weight for x in all_companies), 2)
    return sorted(all_companies, key=lambda x: x.symbol), stock_index, highest_for_day, lowest_close_for_day
